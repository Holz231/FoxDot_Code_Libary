you cannot simply just use my_function(my_timevar) unless the function is only performing basic mathematical operations.
If it is doing something more complex, such as using if-else statements, then you need to know about the TimeVar transform method. 
Let’s look at an example:


def odd_test(num):
    return 5 if num % 2 == 1 else 3
    
    And here is my TimeVar:

my_var = var([0, 1, 2, 3])

If I call odd_test(my_var) then it will return its output (3 or 5) based on the current value of my_var and the value will stay the same,
even if my_var changes. Try it yourself to see. To make sure you always return the correct value given my_var as an input,
you need to call the transform method, which takes a callable object, usually a function, as an input. Note that this callable function can only take
one argument as an input.

my_output = my_var.transform(odd_test)

Now my_output will always be 5 whenever my_var is odd and 3 whenever it is even. If you are an advanced Python user you can even create a class with a __call__() method to create a callable object and use that as an input for the transform method to hold some sort of state between transformations e.g. count the number of times it was called and change the value every 10 times.





>>> def odd_test(num):
...    return 5 if num % 2 == 1 else 3

>>> p1 >> pads([0, 1, 2, 3], dur=4)
>>> p2 >> pluck(p1.pitch.transform(odd_test), dur=1/2)
>>> print(p1.pitch, p2.pitch)
0, 5
>>> print(p1.pitch, p2.pitch)
1, 3





>>> def odd_test(num):
...     """ Convert an even number to 3 and an odd to 5 """
...     return 5 if num % 2 == 1 else 3

>>> c = c.transform(odd_test)
>>> print(a, b, c)
P[0, 1, 2, 3], P[1, 3, 5, 7], P[3, 5, 3, 5]





>>> def odd_test(num):
...    return 5 if num % 2 == 1 else 3

>>> my_odd_gen = odd_test(PRand(0, 10))
>>> print(my_odd_gen)


The num % 2 returns a new PRand and not a number, so when it is asked “is this equal to 1?” it will always return False, and consequently, 3. 
To actually apply the function to the values in our Pattern Generator, we need to use the transform method and supply it with the function.


>>> my_odd_gen = PRand(0, 10).transform(odd_test)
>>> print(my_odd_gen)
PRand(lambda None)

>>> print(my_odd_gen[:10])
P[3, 3, 3, 5, 3, 3, 5, 3, 5, 3]
